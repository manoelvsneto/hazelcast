# Azure DevOps Pipeline para Hazelcast Client no MicroK8s
# Pipeline para build e deploy apenas do cliente Hazelcast
pool:
  name: Arm64
  vmImage: 'ubuntu-22.04'

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - src/*
      - pom.xml
      - Dockerfile*
      - k8s/*

variables:
  # Configurações básicas
  mavenPomFile: 'pom.xml'
  javaVersion: '11'
  
  # Configurações do Docker - CONFIGURE ESTAS VARIÁVEIS
  dockerRegistryServiceConnection: 'DockerConnection'  # Nome da service connection no Azure DevOps
  imageRepository: 'manoelvsneto/hazelcast-client'
  containerRegistry: 'DockerConnection'           # Substitua pelo seu ACR
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile.arm64'
  tag: '$(Build.BuildId)'
  
  # Configurações do Kubernetes - CONFIGURE ESTAS VARIÁVEIS  
  kubernetesServiceConnection: 'K8SOracleCloud'   # Nome da service connection no Azure DevOps
  namespace: 'hazelcast'

stages:
- stage: Build
  displayName: 'Build Application'
  jobs:
  - job: BuildJob
    displayName: 'Build and Test'
    pool:
      name: Arm64
      vmImage: 'ubuntu-22.04'
    
    steps:
    - script: |
        # Verificar se Java 11 está disponível
        if command -v java &> /dev/null; then
          echo "Java encontrado: $(java -version 2>&1 | head -1)"
          export JAVA_HOME=$(readlink -f /usr/bin/java | sed "s:bin/java::")
        else
          echo "Instalando OpenJDK 11..."
          sudo apt-get update
          sudo apt-get install -y openjdk-11-jdk
          export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-arm64
        fi
        
        # Verificar se Maven está disponível
        if ! command -v mvn &> /dev/null; then
          echo "Instalando Maven..."
          sudo apt-get install -y maven
        fi
        
        echo "##vso[task.setvariable variable=JAVA_HOME]$JAVA_HOME"
        echo "JAVA_HOME set to: $JAVA_HOME"
        java -version
        mvn -version
      displayName: 'Setup Java 11 and Maven'
    
    - script: |
        mvn clean compile
      displayName: 'Maven Compile'
      env:
        JAVA_HOME: $(JAVA_HOME)
    
    - script: |
        mvn test
      displayName: 'Run Tests'
      env:
        JAVA_HOME: $(JAVA_HOME)
    
    - script: |
        mvn package -DskipTests
      displayName: 'Package Application'
      env:
        JAVA_HOME: $(JAVA_HOME)
    
    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      condition: succeededOrFailed()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/surefire-reports/TEST-*.xml'
        mergeTestResults: true
    
    - task: CopyFiles@2
      displayName: 'Copy Artifacts'
      inputs:
        SourceFolder: '$(Build.SourcesDirectory)'
        Contents: |
          target/*.jar
          k8s/**
          Dockerfile*
        TargetFolder: '$(Build.ArtifactStagingDirectory)'
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Artifacts'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'

- stage: Docker
  displayName: 'Build Docker Image'
  dependsOn: Build
  jobs:
  - job: DockerJob
    displayName: 'Docker Build and Push'
    pool:
      name: Arm64
      vmImage: 'ubuntu-22.04'
    
    steps:
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Artifacts'
      inputs:
        artifactName: 'drop'
        downloadPath: '$(System.ArtifactsDirectory)'
    
    - script: |
        # Criar Dockerfile otimizado para usar JAR pré-compilado
        cat > Dockerfile.runtime <<EOF
        # Runtime Dockerfile para JAR pré-compilado
        FROM --platform=linux/arm64 eclipse-temurin:11-jre
        
        WORKDIR /app
        
        # Install required packages and create user
        RUN apt-get update && \\
            apt-get install -y --no-install-recommends \\
            curl \\
            procps && \\
            rm -rf /var/lib/apt/lists/* && \\
            groupadd -r hazelcast && \\
            useradd -r -g hazelcast hazelcast
        
        # Create logs directory
        RUN mkdir -p /app/logs && \\
            chown -R hazelcast:hazelcast /app
        
        # Copy JAR from build artifacts
        COPY target/*.jar app.jar
        
        # Set user
        USER hazelcast
        
        # Health check
        HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \\
            CMD curl -f http://localhost:8080/health || exit 1
        
        # Expose port
        EXPOSE 8080
        
        # Run application
        ENTRYPOINT ["java", "-jar", "app.jar"]
        EOF
        
        echo "Dockerfile.runtime criado:"
        cat Dockerfile.runtime
      displayName: 'Create Runtime Dockerfile'
    
    - task: Docker@2
      displayName: 'Build and Push Docker Image'
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: '$(imageRepository)'
        command: 'buildAndPush'
        Dockerfile: 'Dockerfile.runtime'
        buildContext: '$(System.ArtifactsDirectory)/drop'
        tags: |
          $(tag)
          latest
        arguments: '--platform linux/arm64'

- stage: Deploy
  displayName: 'Deploy to MicroK8s'
  dependsOn: Docker
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployJob
    displayName: 'Deploy to Kubernetes'
    pool:
      name: Arm64
      vmImage: 'ubuntu-22.04'
    environment: 'microk8s-cluster'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadBuildArtifacts@0
            displayName: 'Download Artifacts'
            inputs:
              artifactName: 'drop'
              downloadPath: '$(System.ArtifactsDirectory)'
          
          - script: |
              # Substituir placeholders nos manifestos
              sed -i "s|localhost:32000/hazelcast-client:latest|$(imageRepository):$(tag)|g" $(System.ArtifactsDirectory)/drop/k8s/hazelcast-client-deployment.yaml
              echo "Manifest atualizado:"
              cat $(System.ArtifactsDirectory)/drop/k8s/hazelcast-client-deployment.yaml
            displayName: 'Update Manifest with New Image'
          
          - script: |
              # Debug: Verificar conectividade com cluster
              echo "Verificando conectividade com cluster Kubernetes..."
              kubectl cluster-info --insecure-skip-tls-verify || echo "Falha na conexão inicial"
              kubectl get nodes --insecure-skip-tls-verify || echo "Falha ao listar nodes"
              kubectl get namespaces --insecure-skip-tls-verify || echo "Falha ao listar namespaces"
              
              # Verificar se namespace existe, criar se necessário
              kubectl get namespace $(namespace) --insecure-skip-tls-verify || \
              kubectl create namespace $(namespace) --insecure-skip-tls-verify
            displayName: 'Debug Kubernetes Connection'
          
          - task: Kubernetes@1
            displayName: 'Deploy Hazelcast Client'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              namespace: '$(namespace)'
              command: 'apply'
              arguments: '-f $(System.ArtifactsDirectory)/drop/k8s/hazelcast-client-deployment.yaml --insecure-skip-tls-verify'
          
          - script: |
              echo "Aguardando deployment..."
              kubectl wait --for=condition=available --timeout=300s deployment/hazelcast-client -n $(namespace) --insecure-skip-tls-verify
              echo "Verificando status do deployment:"
              kubectl get pods -n $(namespace) -l app=hazelcast-client --insecure-skip-tls-verify
              kubectl get deployment hazelcast-client -n $(namespace) --insecure-skip-tls-verify
              echo "Verificando logs dos pods (últimas 20 linhas):"
              kubectl logs -n $(namespace) -l app=hazelcast-client --tail=20 --insecure-skip-tls-verify || echo "Nenhum log disponível ainda"
            displayName: 'Verify Deployment'
